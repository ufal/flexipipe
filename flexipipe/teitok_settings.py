"""
TEITOK settings.xml parser and integration.

This module handles reading and parsing TEITOK settings.xml files to extract:
- Attribute mappings (XML tags -> internal attribute names)
- Default language settings
- CQP corpus attributes (pattributes/sattributes)
- XML file defaults
- TEI header metadata defaults

TEITOK settings.xml structure:
- /defaults: Default settings including language (@lang attribute)
- /cqp: CQP corpus configuration (pattributes, sattributes)
- /xmlfiles: XML file defaults (language, etc.)
- /teiheader: Text-level metadata defaults
- /flexipipe: Preferred backend/model configuration per language
- /neotag/parameters/item: Tagger-specific parameters (handled by C++ code)

TEITOK Settings Priority:
1. tmp/cqpsettings.xml (highest priority) - Merged shared (Apache shared_folder) + local settings
2. Resources/settings.xml - Standard TEITOK location
3. settings.xml - Root of corpus directory

The tmp/cqpsettings.xml file is automatically generated by TEITOK and includes
settings from Apache's shared_folder (shared across all projects) merged with
local project settings. Local settings override shared settings.
"""

from __future__ import annotations

import xml.etree.ElementTree as ET
from pathlib import Path
from typing import Dict, List, Optional, Set, TYPE_CHECKING

from .language_utils import resolve_language_query, normalize_language_value

if TYPE_CHECKING:
    pass

# Standard TEITOK attribute mappings
# These are the default mappings if not specified in settings.xml
DEFAULT_ATTRIBUTE_MAPPINGS = {
    "xpos": ["xpos", "msd", "pos"],
    "reg": ["reg", "nform"],
    "expan": ["expan", "fform"],
    "lemma": ["lemma"],
    "tokid": ["id", "xml:id"],
}

TRUTHY_VALUES = {"1", "true", "yes", "on"}

# Standard CQP attributes that map to internal attributes
CQP_ATTRIBUTE_MAPPINGS = {
    "pos": "xpos",
    "msd": "xpos",
    "lemma": "lemma",
    "reg": "reg",
    "nform": "reg",
    "expan": "expan",
    "fform": "expan",
}


class TeitokSettings:
    """
    Parsed TEITOK settings.xml configuration.
    
    Attributes:
        attribute_mappings: Dict mapping internal attribute names to lists of XML attribute names
        default_language: Default language code from settings
        cqp_pattributes: CQP positional attributes (token-level)
        cqp_sattributes: CQP structural attributes (sentence/document-level)
        xmlfile_defaults: Default values for XML file processing
        teiheader_defaults: Default TEI header metadata
    """
    
    def __init__(self):
        self.attribute_mappings: Dict[str, List[str]] = dict(DEFAULT_ATTRIBUTE_MAPPINGS)
        self.default_language: Optional[str] = None
        self.cqp_pattributes: List[str] = []
        self.cqp_sattributes: List[str] = []  # Flat list for backward compatibility
        self.cqp_sattributes_by_region: Dict[str, List[str]] = {}  # Region -> list of attributes
        self.cqp_sattributes_by_level: Dict[str, Dict[str, List[str]]] = {}  # level -> {region: [attrs]} (text, p, s)
        self.explicit_flexipipe_mappings: Dict[str, str] = {}  # XML attr name -> internal attr name (from flexipipe="..." attribute)
        self.xmlfile_defaults: Dict[str, str] = {}
        self.teiheader_defaults: Dict[str, str] = {}
        self.settings_path: Optional[Path] = None
        self.flexipipe_preferences: Dict[str, Dict[str, str]] = {}
        self.known_tags_only: bool = False
        self.use_raw_text: bool = False
        self.download_model: bool = False
        self.defined_token_attributes: Set[str] = set()
        self.form_hierarchy: Dict[str, Optional[str]] = {}  # form_name -> parent_form_name (None for base)
        self.default_form: str = "form"  # Default form attribute name
    
    @classmethod
    def load(cls, settings_path: Path) -> TeitokSettings:
        """
        Load and parse a TEITOK settings.xml file.
        
        If loading from tmp/cqpsettings.xml, also checks Resources/settings.xml
        for /defaults/@lang since that section is typically not in cqpsettings.xml.
        
        Args:
            settings_path: Path to settings.xml file
            
        Returns:
            Parsed TeitokSettings object
        """
        settings = cls()
        settings.settings_path = settings_path
        
        if not settings_path.exists():
            # Return default settings if file doesn't exist
            return settings
        
        try:
            tree = ET.parse(settings_path)
            root = tree.getroot()
        except ET.ParseError as e:
            # Return default settings if parsing fails
            return settings
        
        # Parse /defaults section for default language (highest priority)
        settings._parse_defaults_section(root)
        
        # Parse /cqp section for pattributes and sattributes
        settings._parse_cqp_section(root)
        
        # Parse /xmlfiles section for defaults
        settings._parse_xmlfiles_section(root)
        
        # Parse /teiheader section for metadata defaults
        settings._parse_teiheader_section(root)
        
        # Parse /flexipipe section for preferred backend/model per language
        settings._parse_flexipipe_section(root)
        
        # If we loaded from tmp/cqpsettings.xml, also check Resources/settings.xml
        # for /defaults/@lang since that section is typically not in cqpsettings.xml
        if settings_path.name == "cqpsettings.xml" and "tmp" in settings_path.parts:
            # Look for Resources/settings.xml in the same directory structure
            # tmp/cqpsettings.xml -> Resources/settings.xml
            resources_settings = settings_path.parent.parent / "Resources" / "settings.xml"
            if resources_settings.exists():
                try:
                    resources_tree = ET.parse(resources_settings)
                    resources_root = resources_tree.getroot()
                    # Only parse defaults section from Resources/settings.xml
                    # (don't override CQP attributes from cqpsettings.xml)
                    if not settings.default_language:
                        settings._parse_defaults_section(resources_root)
                    # Also check xmlfiles and teiheader for language if still not set
                    if not settings.default_language:
                        settings._parse_xmlfiles_section(resources_root)
                    if not settings.default_language:
                        settings._parse_teiheader_section(resources_root)
                    settings._parse_flexipipe_section(resources_root, prefer_existing=True)
                except ET.ParseError:
                    # Ignore parsing errors in Resources/settings.xml
                    pass
        
        # Build attribute mappings from CQP attributes
        settings._build_attribute_mappings()
        
        return settings
    
    def _parse_cqp_section(self, root: ET.Element) -> None:
        """Parse /cqp section for pattributes and sattributes."""
        cqp_elem = root.find(".//cqp")
        if cqp_elem is None:
            return
        
        # Parse pattributes (positional attributes - token-level)
        # TEITOK uses <item key="..."> elements in cqpsettings.xml
        # but may also use <attribute name="..."> in regular settings.xml
        # Future: <item key="..." flexipipe="xpos"> explicitly maps to standard attribute
        pattributes_elem = cqp_elem.find("pattributes")
        if pattributes_elem is not None:
            # Try <item key="..."> format (cqpsettings.xml)
            for item_elem in pattributes_elem.findall("item"):
                attr_name = item_elem.get("key")
                if attr_name:
                    attr_name = attr_name.strip()
                    self.cqp_pattributes.append(attr_name)
                    self.defined_token_attributes.add(attr_name)
                    # Check for explicit flexipipe mapping attribute
                    flexipipe_map = item_elem.get("flexipipe")
                    if flexipipe_map:
                        self.explicit_flexipipe_mappings[attr_name] = flexipipe_map.strip()
            # Also try <attribute name="..."> format (settings.xml)
            if not self.cqp_pattributes:
                for attr_elem in pattributes_elem.findall("attribute"):
                    attr_name = attr_elem.get("name") or attr_elem.text
                    if attr_name:
                        attr_name = attr_name.strip()
                        self.cqp_pattributes.append(attr_name)
                        self.defined_token_attributes.add(attr_name)
                        # Check for explicit flexipipe mapping attribute
                        flexipipe_map = attr_elem.get("flexipipe")
                        if flexipipe_map:
                            self.explicit_flexipipe_mappings[attr_name] = flexipipe_map.strip()
        
        # Parse sattributes (structural attributes - sentence/document-level)
        # sattributes have a nested structure: region names contain the actual attributes
        # e.g., <item key="text" level="text"><item key="title"/>...</item>
        sattributes_elem = cqp_elem.find("sattributes")
        if sattributes_elem is not None:
            # Try <item key="..."> format (cqpsettings.xml)
            # First-level items are region names (like "text", "s", etc.)
            # Second-level items are the actual sattributes
            for region_elem in sattributes_elem.findall("item"):
                region_name = region_elem.get("key")
                level = region_elem.get("level", "").lower()  # text, p, s
                # Check if this is a region (has nested items or level attribute)
                if level or len(region_elem.findall("item")) > 0:
                    # This is a region, get nested attributes
                    region_attrs = []
                    for attr_elem in region_elem.findall("item"):
                        attr_name = attr_elem.get("key")
                        if attr_name:
                            attr_name = attr_name.strip()
                            region_attrs.append(attr_name)
                            # Add prefixed version to flat list: region_attr
                            if region_name:
                                self.cqp_sattributes.append(f"{region_name}_{attr_name}")
                            else:
                                self.cqp_sattributes.append(attr_name)
                    if region_name and region_attrs:
                        self.cqp_sattributes_by_region[region_name] = region_attrs
                        # Track by level for mapping to CoNLL-U
                        if level:
                            if level not in self.cqp_sattributes_by_level:
                                self.cqp_sattributes_by_level[level] = {}
                            self.cqp_sattributes_by_level[level][region_name] = region_attrs
                else:
                    # This might be a direct attribute (not in a region)
                    attr_name = region_elem.get("key")
                    if attr_name:
                        attr_name = attr_name.strip()
                        self.cqp_sattributes.append(attr_name)
            # Also try <attribute name="..."> format (settings.xml)
            if not self.cqp_sattributes:
                for attr_elem in sattributes_elem.findall("attribute"):
                    attr_name = attr_elem.get("name") or attr_elem.text
                    if attr_name:
                        self.cqp_sattributes.append(attr_name.strip())
    
    def _parse_defaults_section(self, root: ET.Element) -> None:
        """Parse /defaults section for default language and other defaults."""
        defaults_elem = root.find(".//defaults")
        if defaults_elem is None:
            return
        
        # Default language is typically in /defaults/@lang
        lang = defaults_elem.get("lang")
        if lang:
            self.default_language = lang
        
        # Also check for language attribute (alternative)
        if not self.default_language:
            lang = defaults_elem.get("language")
            if lang:
                self.default_language = lang
    
    def _parse_xmlfiles_section(self, root: ET.Element) -> None:
        """Parse /xmlfiles section for XML file processing defaults."""
        xmlfiles_elem = root.find(".//xmlfiles")
        if xmlfiles_elem is None:
            return
        
        # Look for default language in various places (only if not already set from /defaults)
        # 1. Direct language attribute
        if not self.default_language:
            lang = xmlfiles_elem.get("language")
            if lang:
                self.default_language = lang
        
        # 2. Language element
        if not self.default_language:
            lang_elem = xmlfiles_elem.find("language")
            if lang_elem is not None:
                self.default_language = lang_elem.text or lang_elem.get("value")
        
        # Store other defaults
        for key, value in xmlfiles_elem.attrib.items():
            if key != "language":
                self.xmlfile_defaults[key] = value
                # Check for defaultform attribute
                if key == "defaultform":
                    self.default_form = value
        
        # Parse forms hierarchy from <pattributes><forms>
        pattributes_elem = xmlfiles_elem.find("pattributes")
        if pattributes_elem is not None:
            forms_elem = pattributes_elem.find("forms")
            if forms_elem is not None:
                # Build form hierarchy: form_name -> parent_form_name
                # Base form (pform) has no parent (None)
                form_items = {}
                for item_elem in forms_elem.findall("item"):
                    form_key = item_elem.get("key")
                    if form_key:
                        inherit_from = item_elem.get("inherit")
                        form_items[form_key] = inherit_from
                
                # Build hierarchy: resolve inheritance chain
                # pform is the base (no inherit attribute, or explicitly set to None)
                # For each form, trace back to find the base
                self.form_hierarchy = {}
                for form_name, inherit_from in form_items.items():
                    if inherit_from:
                        self.form_hierarchy[form_name] = inherit_from
                    else:
                        # No inherit means this is a base form (like pform)
                        self.form_hierarchy[form_name] = None
        
        # Parse child elements as defaults
        for child in xmlfiles_elem:
            if child.tag not in ("language", "pattributes", "sattributes"):
                self.xmlfile_defaults[child.tag] = child.text or child.get("value", "")
    
    def _parse_teiheader_section(self, root: ET.Element) -> None:
        """Parse /teiheader section for TEI header metadata defaults."""
        teiheader_elem = root.find(".//teiheader")
        if teiheader_elem is None:
            return
        
        # Parse language from teiheader (can override xmlfiles)
        lang_elem = teiheader_elem.find("language")
        if lang_elem is not None:
            lang_value = lang_elem.text or lang_elem.get("value") or lang_elem.get("code")
            if lang_value:
                self.default_language = lang_value
        
        # Store other teiheader defaults
        for child in teiheader_elem:
            if child.tag != "language":
                self.teiheader_defaults[child.tag] = child.text or child.get("value", "")
    
    def _parse_flexipipe_section(self, root: ET.Element, *, prefer_existing: bool = False) -> None:
        """Parse <flexipipe> section for language-specific backend/model settings."""
        flexipipe_elem = root.find(".//flexipipe")
        if flexipipe_elem is None:
            return
        
        # Optional flags on <flexipipe>, e.g. known-tags-only="true", use-raw-text="true"
        # known-tags-only
        flag_value = (
            flexipipe_elem.get("known-tags-only")
            or flexipipe_elem.get("known_tags_only")
            or flexipipe_elem.get("known-tags")
        )
        if flag_value:
            if flag_value.strip().lower() in TRUTHY_VALUES:
                self.known_tags_only = True
        else:
            flag_elem = (
                flexipipe_elem.find("known-tags-only")
                or flexipipe_elem.find("known_tags_only")
                or flexipipe_elem.find("./options/known-tags-only")
                or flexipipe_elem.find("./options/known_tags_only")
            )
            if flag_elem is not None:
                text_value = (flag_elem.text or flag_elem.get("value") or "").strip().lower()
                if text_value in TRUTHY_VALUES:
                    self.known_tags_only = True
        
        # use-raw-text
        raw_text_value = (
            flexipipe_elem.get("use-raw-text")
            or flexipipe_elem.get("use_raw_text")
            or flexipipe_elem.get("raw-text")
        )
        if raw_text_value:
            if raw_text_value.strip().lower() in TRUTHY_VALUES:
                self.use_raw_text = True
        else:
            raw_text_elem = (
                flexipipe_elem.find("use-raw-text")
                or flexipipe_elem.find("use_raw_text")
                or flexipipe_elem.find("./options/use-raw-text")
                or flexipipe_elem.find("./options/use_raw_text")
            )
            if raw_text_elem is not None:
                text_value = (raw_text_elem.text or raw_text_elem.get("value") or "").strip().lower()
                if text_value in TRUTHY_VALUES:
                    self.use_raw_text = True
        
        # download-model
        download_model_value = (
            flexipipe_elem.get("download-model")
            or flexipipe_elem.get("download_model")
            or flexipipe_elem.get("downloadModel")
        )
        if download_model_value:
            if download_model_value.strip().lower() in TRUTHY_VALUES:
                self.download_model = True
        else:
            download_model_elem = (
                flexipipe_elem.find("download-model")
                or flexipipe_elem.find("download_model")
                or flexipipe_elem.find("./options/download-model")
                or flexipipe_elem.find("./options/download_model")
            )
            if download_model_elem is not None:
                text_value = (download_model_elem.text or download_model_elem.get("value") or "").strip().lower()
                if text_value in TRUTHY_VALUES:
                    self.download_model = True
        
        def _store_pref(lang_key: Optional[str], backend: Optional[str], model: Optional[str]) -> None:
            if not lang_key:
                return
            key = lang_key.strip()
            if not key:
                return
            normalized = normalize_language_value(key)
            pref_key = normalized or key
            if prefer_existing and pref_key in self.flexipipe_preferences:
                return
            pref: Dict[str, str] = {}
            if backend:
                pref["backend"] = backend.strip()
            if model:
                pref["model"] = model.strip()
            if pref:
                self.flexipipe_preferences[pref_key] = pref
        
        # <flexipipe><language ...> entries
        for lang_elem in flexipipe_elem.findall("language"):
            code = lang_elem.get("code") or lang_elem.get("iso") or lang_elem.get("id") or lang_elem.get("name")
            backend = lang_elem.get("backend") or lang_elem.findtext("backend")
            model = lang_elem.get("model") or lang_elem.findtext("model")
            _store_pref(code, backend, model)
        
        # <flexipipe><models><item .../> entries
        models_elem = flexipipe_elem.find("models")
        if models_elem is not None:
            for item_elem in models_elem.findall("item"):
                code = item_elem.get("key") or item_elem.get("language") or item_elem.get("id")
                backend = item_elem.get("backend")
                model = item_elem.get("model")
                _store_pref(code, backend, model)
    
    def _build_attribute_mappings(self) -> None:
        """
        Build attribute mappings from CQP pattributes.
        
        CQP pattributes define which XML attributes are used for token-level features.
        We map these to our internal attribute names.
        
        Priority:
        1. Explicit flexipipe="..." attribute (highest priority)
        2. Standard CQP_ATTRIBUTE_MAPPINGS
        3. Default mappings
        """
        # Start with defaults
        mappings = dict(DEFAULT_ATTRIBUTE_MAPPINGS)
        
        # First, handle explicit flexipipe mappings (highest priority)
        for xml_attr, internal_attr in self.explicit_flexipipe_mappings.items():
            if internal_attr not in mappings:
                mappings[internal_attr] = []
            if xml_attr not in mappings[internal_attr]:
                mappings[internal_attr].insert(0, xml_attr)  # Prepend to prioritize
        
        # Map CQP pattributes to internal attributes (standard mappings)
        for pattr in self.cqp_pattributes:
            # Skip if already explicitly mapped via flexipipe attribute
            if pattr in self.explicit_flexipipe_mappings:
                continue
            # Check if this CQP attribute maps to an internal attribute
            for cqp_name, internal_name in CQP_ATTRIBUTE_MAPPINGS.items():
                if pattr.lower() == cqp_name.lower():
                    # Add to the mapping list if not already present
                    if internal_name not in mappings:
                        mappings[internal_name] = []
                    if pattr not in mappings[internal_name]:
                        mappings[internal_name].insert(0, pattr)  # Prepend to prioritize
                    else:
                        # Move to front if already present (prioritize CQP-defined attributes)
                        mappings[internal_name].remove(pattr)
                        mappings[internal_name].insert(0, pattr)
        
        self.attribute_mappings = mappings
    
    def get_attribute_mapping(self, internal_attr: str) -> List[str]:
        """
        Get the list of XML attribute names for an internal attribute.
        
        Args:
            internal_attr: Internal attribute name (e.g., "xpos", "reg", "lemma")
            
        Returns:
            List of XML attribute names to check (in priority order)
        """
        return self.attribute_mappings.get(internal_attr, [internal_attr])
    
    def get_defined_token_attributes(self) -> Set[str]:
        """Return the set of token-level attributes explicitly defined in settings."""
        return set(self.defined_token_attributes)
    
    def resolve_xml_attribute(self, internal_attr: str, default: Optional[str] = None) -> Optional[str]:
        """
        Resolve the XML attribute name that should be used for an internal attribute.
        
        If known-tags-only mode is enabled, only attributes explicitly defined in
        the TEITOK settings will be returned.
        """
        candidates = self.attribute_mappings.get(internal_attr, [])
        if not candidates:
            candidates = [default or internal_attr]
        
        for candidate in candidates:
            if not candidate:
                continue
            if self.known_tags_only:
                if candidate in self.defined_token_attributes:
                    return candidate
            else:
                return candidate
        
        if self.known_tags_only:
            return None
        
        return default or (candidates[0] if candidates else internal_attr)
    
    def build_output_attribute_map(self) -> Dict[str, Optional[str]]:
        """
        Build a mapping of internal attribute names -> XML attribute names to use
        when writing TEITOK output.
        """
        internal_attrs = [
            "lemma",
            "xpos",
            "upos",
            "feats",
            "reg",
            "expan",
            "mod",
            "trslit",
            "ltrslit",
            "head",
            "deprel",
            "deps",
            "misc",
        ]
        mapping: Dict[str, Optional[str]] = {}
        for attr in internal_attrs:
            mapping[attr] = self.resolve_xml_attribute(attr, default=attr)
        return mapping
    
    def get_language(self, override: Optional[str] = None) -> Optional[str]:
        """
        Get the default language, with optional override.
        
        Args:
            override: Language code to use if provided (takes precedence)
            
        Returns:
            Language code, or None if not set
        """
        return override or self.default_language
    
    def get_flexipipe_preference(self, language: Optional[str]) -> Optional[Dict[str, str]]:
        """Return preferred backend/model for a language, if defined."""
        if not language or not self.flexipipe_preferences:
            return None
        
        query = resolve_language_query(language)
        iso_candidates = {code.lower() for code in query.get("iso", set())}
        normalized_candidates = {normalize_language_value(name) for name in query.get("names", set()) if name}
        normalized_candidates.add(query.get("raw_normalized"))
        
        for key, pref in self.flexipipe_preferences.items():
            if not pref:
                continue
            normalized_key = normalize_language_value(key)
            key_lower = key.lower()
            if key_lower == language.lower():
                return pref
            if key_lower in iso_candidates:
                return pref
            if normalized_key and normalized_key in normalized_candidates:
                return pref
        return None


def find_settings_xml(corpus_path: Path) -> Optional[Path]:
    """
    Find settings.xml file in a TEITOK corpus directory.
    
    TEITOK can merge shared settings (from Apache shared_folder) with local settings
    and write the result to tmp/cqpsettings.xml. This merged file takes priority.
    
    Looks for settings in this order:
    1. tmp/cqpsettings.xml (merged shared + local settings, highest priority)
    2. Resources/settings.xml (standard TEITOK location)
    3. settings.xml (root of corpus)
    4. Parent directories up to 3 levels
    
    Args:
        corpus_path: Path to corpus directory or XML file
        
    Returns:
        Path to settings.xml if found, None otherwise
    """
    # If corpus_path is a file, use its directory
    if corpus_path.is_file():
        search_dir = corpus_path.parent
    else:
        search_dir = corpus_path
    
    # First priority: tmp/cqpsettings.xml (merged shared + local settings)
    # This is written by TEITOK and includes Apache shared_folder settings
    cqpsettings_path = search_dir / "tmp" / "cqpsettings.xml"
    if cqpsettings_path.exists() and cqpsettings_path.is_file():
        return cqpsettings_path
    
    # Standard locations
    candidates = [
        search_dir / "Resources" / "settings.xml",
        search_dir / "settings.xml",
    ]
    
    # Check parent directories (up to 3 levels)
    current = search_dir
    for _ in range(3):
        current = current.parent
        # Also check for tmp/cqpsettings.xml in parent directories
        parent_cqpsettings = current / "tmp" / "cqpsettings.xml"
        if parent_cqpsettings.exists() and parent_cqpsettings.is_file():
            return parent_cqpsettings
        candidates.extend([
            current / "Resources" / "settings.xml",
            current / "settings.xml",
        ])
    
    for candidate in candidates:
        if candidate.exists() and candidate.is_file():
            return candidate
    
    return None


def load_teitok_settings(settings_path: Optional[Path] = None, corpus_path: Optional[Path] = None) -> TeitokSettings:
    """
    Load TEITOK settings from a file or by searching for it.
    
    If searching, prioritizes tmp/cqpsettings.xml (merged shared + local settings)
    over Resources/settings.xml or settings.xml.
    
    Args:
        settings_path: Explicit path to settings.xml (takes precedence)
        corpus_path: Path to corpus directory or XML file (used to search for settings.xml)
        
    Returns:
        TeitokSettings object (may have defaults if settings.xml not found)
    """
    if settings_path:
        return TeitokSettings.load(settings_path)
    
    if corpus_path:
        found_path = find_settings_xml(Path(corpus_path))
        if found_path:
            return TeitokSettings.load(found_path)
    
    # Return default settings
    return TeitokSettings()

